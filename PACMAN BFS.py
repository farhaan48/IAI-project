# -*- coding: utf-8 -*-
"""Untitled39.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nw_ZW81nvyVoGkfa1Alb4zdLc3i2GXVQ
"""

from collections import deque

def bfs(r, c, pacman_r, pacman_c, food_r, food_c, grid):
    # Define directions: UP, LEFT, RIGHT, DOWN
    directions = [(-1, 0), (0, -1), (0, 1), (1, 0)]

    # Initialize queue, visited set, and parent dictionary
    queue = deque([(pacman_r, pacman_c)])
    visited = set([(pacman_r, pacman_c)])
    parent = {}
    expanded = []

    while queue:
        current = queue.popleft()
        expanded.append(current)

        if current == (food_r, food_c):
            break

        for dr, dc in directions:
            nr, nc = current[0] + dr, current[1] + dc
            if 0 <= nr < r and 0 <= nc < c and grid[nr][nc] != '%' and (nr, nc) not in visited:
                queue.append((nr, nc))
                visited.add((nr, nc))
                parent[(nr, nc)] = current

    # Print number of nodes expanded
    print(len(expanded))

    # Print expanded nodes
    for node in expanded:
        print(f"{node[0]} {node[1]}")

    # Reconstruct path
    path = []
    current = (food_r, food_c)
    while current != (pacman_r, pacman_c):
        path.append(current)
        current = parent[current]
    path.append((pacman_r, pacman_c))
    path.reverse()

    # Print path length and path
    print(len(path) - 1)
    for node in path:
        print(f"{node[0]} {node[1]}")

def nextMove(r, c, pacman_r, pacman_c, food_r, food_c, grid):
    bfs(r, c, pacman_r, pacman_c, food_r, food_c, grid)

# Read input
pacman_r, pacman_c = map(int, input().split())
food_r, food_c = map(int, input().split())
r, c = map(int, input().split())
grid = [input() for _ in range(r)]

# Call the nextMove function
nextMove(r, c, pacman_r, pacman_c, food_r, food_c, grid)