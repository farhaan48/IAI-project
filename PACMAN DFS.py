# -*- coding: utf-8 -*-
"""Untitled39.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nw_ZW81nvyVoGkfa1Alb4zdLc3i2GXVQ
"""

def dfs(r, c, pacman_r, pacman_c, food_r, food_c, grid):
    # Define directions: UP, LEFT, RIGHT, DOWN
    directions = [(-1, 0), (0, -1), (0, 1), (1, 0)]

    # Initialize stack, visited set, and parent dictionary
    stack = [(pacman_r, pacman_c)]
    visited = set()
    parent = {}
    explored = []

    while stack:
        current = stack.pop()
        if current not in visited:
            visited.add(current)
            explored.append(current)

            if current == (food_r, food_c):
                break

            for dr, dc in directions:
                nr, nc = current[0] + dr, current[1] + dc
                if 0 <= nr < r and 0 <= nc < c and grid[nr][nc] != '%' and (nr, nc) not in visited:
                    stack.append((nr, nc))
                    if (nr, nc) not in parent:
                        parent[(nr, nc)] = current

    # Print number of nodes explored
    print(len(explored))

    # Print explored nodes
    for node in explored:
        print(f"{node[0]} {node[1]}")

    # Reconstruct path
    path = []
    current = (food_r, food_c)
    while current != (pacman_r, pacman_c):
        path.append(current)
        current = parent[current]
    path.append((pacman_r, pacman_c))
    path.reverse()

    # Print path length and path
    print(len(path) - 1)
    for node in path:
        print(f"{node[0]} {node[1]}")

# Read input
pacman_r, pacman_c = map(int, input().split())
food_r, food_c = map(int, input().split())
r, c = map(int, input().split())
grid = [input() for _ in range(r)]

# Call the dfs function
dfs(r, c, pacman_r, pacman_c, food_r, food_c, grid)